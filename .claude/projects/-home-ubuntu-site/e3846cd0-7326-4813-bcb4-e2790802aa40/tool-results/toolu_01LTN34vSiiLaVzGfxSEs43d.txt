     1→import base64
     2→import hashlib
     3→import json
     4→import traceback
     5→from datetime import datetime
     6→from operator import attrgetter
     7→from zipfile import BadZipfile, ZipFile
     8→
     9→from adminsortable2.admin import SortableInlineAdminMixin
    10→from cryptography.fernet import Fernet
    11→from reversion.admin import VersionAdmin
    12→
    13→from django import forms
    14→from django.contrib import admin
    15→from django.core.exceptions import ValidationError
    16→from django.db import connection, transaction
    17→#Problem Code 처리를 위한 import
    18→from django.db.models import IntegerField
    19→from django.db.models.deletion import Collector
    20→from django.db.models.functions import Cast
    21→from django.forms import BaseInlineFormSet, HiddenInput, ModelForm, NumberInput, Select
    22→from django.http import Http404, HttpResponse, JsonResponse
    23→from django.shortcuts import render
    24→from django.urls import path, reverse, reverse_lazy
    25→from django.utils import timezone
    26→from django.utils.html import format_html
    27→from django.utils.translation import gettext, gettext_lazy as _, ngettext
    28→
    29→from judge.models import (Judge, Language, LanguageLimit, Problem, ProblemClarification, 
    30→                         ProblemData, ProblemPointsVote, ProblemTestCase, 
    31→                         ProblemTranslation, Profile, Solution)
    32→from judge.utils.views import NoBatchDeleteMixin
    33→#TestCase 처리를 위한 import
    34→from judge.views.problem_data import *
    35→from judge.widgets import (AdminHeavySelect2MultipleWidget, AdminMartorWidget, 
    36→                          AdminSelect2MultipleWidget, AdminSelect2Widget, 
    37→                          CheckboxSelectMultipleWithSelectAll)
    38→from judge.widgets.select2 import AdminHeavySelect2Widget
    39→from django.contrib.admin.filters import FieldListFilter
    40→
    41→
    42→class ProblemForm(ModelForm):
    43→    change_message = forms.CharField(max_length=256, label=_('Edit reason'), required=False)
    44→    encryption_key = forms.CharField(
    45→        required=False, 
    46→        widget=forms.PasswordInput(attrs={
    47→            'class': 'encryption-key-input',
    48→            'maxlength': 50,
    49→            'minlength': 4,
    50→            'autocomplete': 'off'
    51→        }),
    52→        label=_('암호화 키'),
    53→        min_length=4,
    54→        max_length=50,
    55→        help_text=_('암호화 키는 4-50자 사이여야 합니다.')
    56→    )
    57→    
    58→    def __init__(self, *args, **kwargs):
    59→        super(ProblemForm, self).__init__(*args, **kwargs)
    60→        self.fields['authors'].widget.can_add_related = False
    61→        self.fields['testers'].widget.can_add_related = False
    62→        self.fields['change_message'].widget.attrs.update({
    63→            'placeholder': gettext('Describe the changes you made (optional)'),
    64→        })
    65→
    66→        # 새 문제 생성 시 is_public을 False(비공개)로 설정
    67→        if not self.instance.pk:  # 새 문제인 경우
    68→            self.initial['is_public'] = False
    69→        
    70→        # description을 선택적 필드로 설정
    71→        self.fields['description'].required = False
    72→        
    73→        # 암호화된 문제인 경우 '복호화 키'로 라벨 변경
    74→        if self.instance and self.instance.pk:
    75→            if self.instance.is_encrypted:
    76→                self.fields['encryption_key'].label = _('복호화 키')
    77→                self.fields['encryption_key'].help_text = _('암호화된 문제를 편집하려면 올바른 복호화 키를 입력하세요.')
    78→                self.fields['description'].widget.attrs['placeholder'] = '(암호화된 내용)'
    79→    
    80→    def clean(self):
    81→        cleaned_data = super().clean()
    82→        is_encrypted = cleaned_data.get('is_encrypted', False)
    83→        encryption_key = cleaned_data.get('encryption_key', '')
    84→        
    85→        # 현재 암호화 상태
    86→        was_encrypted = False
    87→        if self.instance and self.instance.pk:
    88→            # 데이터베이스에서 직접 암호화 상태 확인
    89→            try:
    90→                with connection.cursor() as cursor:
    91→                    cursor.execute("SELECT is_encrypted FROM judge_problem WHERE id = %s", [self.instance.pk])
    92→                    row = cursor.fetchone()
    93→                    if row:
    94→                        was_encrypted = bool(row[0])
    95→            except Exception as e:
    96→                # 오류 발생 시 인스턴스 값 사용
    97→                was_encrypted = self.instance.is_encrypted
    98→        
    99→        # 암호화 활성화 검증
   100→        if is_encrypted and not was_encrypted:
   101→            if not encryption_key:
   102→                raise forms.ValidationError('암호화가 활성화된 경우 암호화 키를 입력해야 합니다.')
   103→            if len(encryption_key) < 4:
   104→                raise forms.ValidationError('암호화 키는 최소 4자 이상이어야 합니다.')
   105→            
   106→            # 암호화 키 복잡성 검증
   107→            if len(encryption_key) > 50:
   108→                raise forms.ValidationError('암호화 키는 최대 50자까지 허용됩니다.')
   109→        
   110→        # 이미 암호화된 문제를 암호화 해제하려는 경우
   111→        elif was_encrypted and not is_encrypted:
   112→            if not encryption_key:
   113→                raise forms.ValidationError('암호화된 문제를 복호화하려면 복호화 키를 입력해야 합니다.')
   114→            
   115→            # 키 해시 검증
   116→            try:
   117→                input_hash = hashlib.sha256(encryption_key.encode('utf-8')).hexdigest()
   118→                db_hash = self.instance.encryption_key_hash or ''
   119→                
   120→                if not db_hash or input_hash != db_hash:
   121→                    raise forms.ValidationError('잘못된 복호화 키입니다. 정확한 복호화 키를 입력하세요.')
   122→            except forms.ValidationError:
   123→                raise
   124→            except Exception as e:
   125→                raise forms.ValidationError(f'복호화 키 검증 중 오류가 발생했습니다: {e}')
   126→        
   127→        # 암호화 상태에서 복호화 키를 입력했을 때
   128→        elif was_encrypted and is_encrypted and encryption_key:
   129→            # 암호화 유지 상태에서 키 입력 처리: 키가 변경되면 안됨
   130→            try:
   131→                input_hash = hashlib.sha256(encryption_key.encode('utf-8')).hexdigest()
   132→                db_hash = self.instance.encryption_key_hash or ''
   133→                
   134→                if input_hash != db_hash:
   135→                    raise forms.ValidationError(
   136→                        '암호화된 상태를 유지하면서 키를 변경할 수 없습니다. 암호화를 해제하려면 먼저 암호화 체크박스를 해제하세요.'
   137→                    )
   138→            except forms.ValidationError:
   139→                raise
   140→            except Exception as e:
   141→                raise forms.ValidationError('복호화 키 검증 중 오류가 발생했습니다.')
   142→        
   143→        return cleaned_data
   144→
   145→    def save(self, commit=True):
   146→        # 기본 필드들을 처리하되 DB에는 아직 저장하지 않음
   147→        instance = super(ProblemForm, self).save(commit=False)
   148→        
   149→        # DB에서 현재 is_encrypted 상태를 직접 확인
   150→        real_is_encrypted = False
   151→        if instance.pk:
   152→            try:
   153→                with connection.cursor() as cursor:
   154→                    cursor.execute("SELECT is_encrypted, encryption_key_hash FROM judge_problem WHERE id = %s", [instance.pk])
   155→                    row = cursor.fetchone()
   156→                    if row:
   157→                        real_is_encrypted = bool(row[0])
   158→            except Exception:
   159→                pass
   160→        
   161→        is_encrypted = self.cleaned_data.get('is_encrypted', False)
   162→        was_encrypted = real_is_encrypted  # 인스턴스 값 대신 DB 값 사용
   163→        encryption_key = self.cleaned_data.get('encryption_key', '')
   164→        
   165→        try:
   166→            if is_encrypted and not was_encrypted and encryption_key:
   167→                # 암호화 처리
   168→                instance._encryption_key = encryption_key
   169→                
   170→            elif was_encrypted and not is_encrypted and encryption_key:
   171→                # 복호화 처리
   172→                if instance.encrypted_description:
   173→                    # 직접 복호화 시도
   174→                    try:
   175→                        # 복호화 시도
   176→                        from judge.utils.encryption import decrypt_text
   177→                        try:
   178→                            decrypted_text = decrypt_text(instance.encrypted_description, encryption_key)
   179→                            
   180→                            # SQL 인젝션 방지: 파라미터화된 쿼리 사용
   181→                            if instance.pk:
   182→                                with connection.cursor() as cursor:
   183→                                    cursor.execute(
   184→                                        """
   185→                                        UPDATE judge_problem 
   186→                                        SET description = %s, 
   187→                                            encrypted_description = NULL, 
   188→                                            encryption_key_hash = NULL, 
   189→                                            is_encrypted = %s
   190→                                        WHERE id = %s
   191→                                        """,
   192→                                        [decrypted_text, False, instance.pk]
   193→                                    )
   194→                                
   195→                                # 인스턴스에도 복호화된 내용 설정
   196→                                instance.description = decrypted_text
   197→                                instance.encrypted_description = None
   198→                                instance.encryption_key_hash = None
   199→                                instance.is_encrypted = False
   200→                                
   201→                                # 추가 저장 방지
   202→                                if commit:
   203→                                    # M2M 관계만 저장
   204→                                    self.save_m2m()
   205→                                    
   206→                                    # 저장 완료 플래그
   207→                                    instance._directly_updated = True
   208→                                    return instance
   209→                        except ValidationError as ve:
   210→                            raise forms.ValidationError(f'복호화 실패: {ve}')
   211→                                
   212→                    except Exception as e:
   213→                        raise forms.ValidationError(f'복호화 중 오류가 발생했습니다: {e}')
   214→            
   215→            # 암호화 유지 상태에서 키 입력 검증 (버그 수정)
   216→            elif was_encrypted and is_encrypted and encryption_key:
   217→                # clean 메서드에서 이미 검증됨 - 추가 조치 필요 없음
   218→                pass
   219→        except Exception as e:
   220→            raise
   221→        
   222→        # 일반 저장 (복호화가 직접 업데이트되지 않은 경우)
   223→        if commit and not hasattr(instance, '_directly_updated'):
   224→            instance.save()
   225→            self.save_m2m()
   226→        
   227→        return instance
   228→
   229→    class Meta:
   230→        widgets = {
   231→            'authors': AdminHeavySelect2MultipleWidget(data_view='profile_select2', attrs={'style': 'width: 100%; display: none;'}),
   232→            # 'curators': AdminHeavySelect2MultipleWidget(data_view='profile_select2', attrs={'style': 'width: 100%'}),
   233→            'testers': AdminHeavySelect2MultipleWidget(data_view='profile_select2', attrs={'style': 'width: 100%'}),
   234→            'banned_users': AdminHeavySelect2MultipleWidget(data_view='profile_select2',
   235→                                                           attrs={'style': 'width: 100%'}),
   236→            # 'organizations': AdminHeavySelect2MultipleWidget(data_view='organization_select2', attrs={'style': 'width: 100%'}),
   237→            'types': AdminSelect2MultipleWidget,
   238→            'group': AdminSelect2Widget,
   239→            'description': AdminMartorWidget(attrs={'data-markdownfy-url': reverse_lazy('problem_preview')}),
   240→            'allowed_languages': CheckboxSelectMultipleWithSelectAll(),
   241→        }
   242→ 
   243→ 
   244→from django.db.models import Q
   245→
   246→class ProblemCombinedInputFilter(FieldListFilter):
   247→    title=' '
   248→    template = 'admin/input_filter/input_filter_problem.html'  # 커스텀 템플릿
   249→
   250→    def __init__(self, field, request, params, model, model_admin, field_path):
   251→        super().__init__(field, request, params, model, model_admin, field_path)
   252→        self.request = request
   253→        self.params = params
   254→
   255→        self.available_usernames = list(
   256→            Profile.objects
   257→            .filter(authored_problems__isnull=False)
   258→            .values_list('user__username', flat=True)
   259→            .distinct()
   260→        )
   261→
   262→    def expected_parameters(self):
   263→        # 여러 필드를 필터하므로 각 필드 이름을 명시
   264→        return ['is_public', 'encryption_status', 'authors', 'name','code']
   265→
   266→    def choices(self, changelist):
   267→        yield {
   268→            'selected': False,
   269→            'query_string': changelist.get_query_string(remove=self.expected_parameters()),
   270→            'display': '초기화',
   271→        }
   272→
   273→    def queryset(self, request, queryset):
   274→        is_public = request.GET.get('is_public')
   275→        encryption_status = request.GET.get('encryption_status')
   276→        authors = request.GET.get('authors')
   277→        name = request.GET.get('name')
   278→        code = request.GET.get('code')
   279→
   280→        if is_public in ['True', 'False']:
   281→            queryset = queryset.filter(is_public=(is_public == 'True'))
   282→
   283→        if encryption_status == 'encrypted':
   284→            queryset = queryset.filter(is_encrypted=True)
   285→        elif encryption_status == 'not_encrypted':
   286→            queryset = queryset.filter(is_encrypted=False)
   287→
   288→        if authors:
   289→            queryset = queryset.filter(authors__user__username__icontains=authors)
   290→
   291→        if code:
   292→            queryset = queryset.filter(code__icontains=code)
   293→            
   294→        if name:
   295→            queryset = queryset.filter(name__icontains=name)
   296→
   297→            
   298→        return queryset
   299→
   300→
   301→class LanguageLimitInlineForm(ModelForm):
   302→    class Meta:
   303→        widgets = {'language': AdminSelect2Widget}
   304→
   305→
   306→class LanguageLimitInline(admin.TabularInline):
   307→    model = LanguageLimit
   308→    fields = ('language', 'time_limit', 'memory_limit')
   309→    form = LanguageLimitInlineForm
   310→    extra = 0
   311→
   312→
   313→class ProblemClarificationForm(ModelForm):
   314→    class Meta:
   315→        widgets = {'description': AdminMartorWidget(attrs={'data-markdownfy-url': reverse_lazy('comment_preview')})}
   316→
   317→
   318→class ProblemClarificationInline(admin.StackedInline):
   319→    model = ProblemClarification
   320→    fields = ('description',)
   321→    form = ProblemClarificationForm
   322→    extra = 0
   323→
   324→
   325→class ProblemSolutionForm(ModelForm):
   326→    def __init__(self, *args, **kwargs):
   327→        super(ProblemSolutionForm, self).__init__(*args, **kwargs)
   328→        self.fields['authors'].widget.can_add_related = False
   329→
   330→    class Meta:
   331→        widgets = {
   332→            'authors': AdminHeavySelect2MultipleWidget(data_view='profile_select2', attrs={'style': 'width: 100%'}),
   333→            'content': AdminMartorWidget(attrs={'data-markdownfy-url': reverse_lazy('solution_preview')}),
   334→        }
   335→
   336→
   337→class ProblemSolutionInline(admin.StackedInline):
   338→    model = Solution
   339→    fields = ('is_public', 'publish_on', 'authors', 'content')
   340→    form = ProblemSolutionForm
   341→    extra = 0
   342→
   343→
   344→class ProblemTranslationForm(ModelForm):
   345→    class Meta:
   346→        widgets = {'description': AdminMartorWidget(attrs={'data-markdownfy-url': reverse_lazy('problem_preview')})}
   347→
   348→
   349→class ProblemTranslationInline(admin.StackedInline):
   350→    model = ProblemTranslation
   351→    fields = ('language', 'name', 'description')
   352→    form = ProblemTranslationForm
   353→    extra = 0
   354→
   355→    def has_permission_full_markup(self, request, obj=None):
   356→        if not obj:
   357→            return True
   358→        return request.user.has_perm('judge.problem_full_markup') or not obj.is_full_markup
   359→
   360→    has_add_permission = has_change_permission = has_delete_permission = has_permission_full_markup
   361→
   362→
   363→## 테스트케이스 인라인 관련 클래스
   364→class TestCaseInlineForm(forms.ModelForm):
   365→    class Meta:
   366→        model = ProblemTestCase
   367→        fields = '__all__'
   368→        widgets = {
   369→            'generator_args': HiddenInput(),
   370→            'input_file': Select(attrs={'style': 'width: 100%'}),
   371→            'output_file': Select(attrs={'style': 'width: 100%'}),
   372→            'type': Select(attrs={'style': 'width: 100%'}),
   373→            'points': NumberInput(attrs={'style': 'width: 4em'}),
   374→            'output_prefix': NumberInput(attrs={'style': 'width: 4.5em'}),
   375→            'output_limit': NumberInput(attrs={'style': 'width: 6em'}),
   376→            'checker_args': HiddenInput(),
   377→        }
   378→
   379→class TestCaseInlineFormset(BaseInlineFormSet):
   380→    def save(self, commit=True):
   381→        instances = super().save(commit=False)
   382→        
   383→        # 삭제된 객체들 처리
   384→        if self.deleted_objects:
   385→            for obj in self.deleted_objects:
   386→                obj.delete()
   387→        
   388→        saved_instances = []
   389→        for instance in instances:
   390→            instance.save()
   391→            saved_instances.append(instance)
   392→            
   393→        # init.yml 생성/업데이트
   394→        try:
   395→            problem = self.instance
   396→            if hasattr(problem, 'data_files'):
   397→                problem_data = problem.data_files
   398→                
   399→                from judge.utils.problem_data import ProblemDataCompiler
   400→                files = []
   401→                if problem_data.zipfile:
   402→                    try:
   403→                        with ZipFile(problem_data.zipfile.path) as zf:
   404→                            files = zf.namelist()
   405→                    except Exception as e:
   406→                        print(f"Error reading zipfile: {e}")
   407→                
   408→                ProblemDataCompiler.generate(
   409→                    problem=problem,
   410→                    data=problem_data,
   411→                    cases=problem.cases.all(),
   412→                    files=files
   413→                )
   414→        except Exception as e:
   415→            print(f"Error generating init.yml: {e}")
   416→            
   417→        return saved_instances
   418→
   419→    def add_fields(self, form, index):
   420→        super().add_fields(form, index)
   421→        
   422→        if self.instance and self.instance.pk:
   423→            input_files = self.get_files(self.instance)
   424→            form.fields['input_file'].widget.choices = input_files
   425→            form.fields['output_file'].widget.choices = input_files
   426→
   427→    def get_files(self, obj):
   428→        if obj and obj.pk:
   429→            problem_data = ProblemData.objects.filter(problem=obj).first()
   430→            if problem_data and problem_data.zipfile:
   431→                try:
   432→                    with ZipFile(problem_data.zipfile.path) as zf:
   433→                        choices = [(name, name) for name in zf.namelist()]
   434→                        return choices
   435→                except BadZipfile:
   436→                    pass
   437→        return []
   438→
   439→
   440→class TestCaseInline(SortableInlineAdminMixin, admin.TabularInline):
   441→    model = ProblemTestCase
   442→    form = TestCaseInlineForm
   443→    formset = TestCaseInlineFormset
   444→    fields = ('order', 'type', 'input_file', 'output_file', 'points')
   445→    extra = 0
   446→    
   447→    def has_add_permission(self, request, obj=None):
   448→        if obj is None or not hasattr(obj, 'data_files') or not obj.data_files.zipfile:
   449→            return False
   450→        return True
   451→        
   452→class ProblemDataInline(admin.TabularInline):
   453→    model = ProblemData
   454→    fields = ['zipfile', 'generator', 'unicode', 'nobigmath']
   455→    form = ProblemDataForm
   456→
   457→class ProblemEncryptionFilter(admin.SimpleListFilter):
   458→    title = '암호화 상태'  # 필터 제목
   459→    parameter_name = 'encryption_status'  # URL 파라미터 이름
   460→
   461→    def lookups(self, request, model_admin):
   462→        return [
   463→            ('encrypted', '암호화된 문제만'),
   464→            ('not_encrypted', '암호화되지 않은 문제만'),
   465→        ]
   466→
   467→    def queryset(self, request, queryset):
   468→        if self.value() == 'encrypted':
   469→            return queryset.filter(is_encrypted=True)
   470→        if self.value() == 'not_encrypted':
   471→            return queryset.filter(is_encrypted=False)
   472→        return queryset
   473→    
   474→from django import forms
   475→
   476→class CustomActionForm(forms.Form):
   477→    action = forms.ChoiceField(
   478→        label="작업",   
   479→        choices=[],           
   480→        required=False,
   481→    )
   482→    select_across = forms.CharField(
   483→        required=False,
   484→        widget=forms.HiddenInput(),   
   485→        label=''
   486→    )
   487→
   488→    def __init__(self, *args, **kwargs):
   489→        super().__init__(*args, **kwargs)
   490→        self.fields['action'].choices.insert(0, ("", "작업을 선택하세요."))
   491→
   492→class ProblemAdmin(VersionAdmin):
   493→    fieldsets = (
   494→        ('문제 설정', {
   495→            'fields': (
   496→                'code', 'name', 'date', 'authors', 'testers',
   497→                ('is_encrypted', 'encryption_key'), 
   498→                'is_public',
   499→                'description', 
   500→            ),
   501→        }),
   502→        # (_('Social Media'), {'classes': ('collapse',), 'fields': ('og_image', 'summary')}),
   503→        (_('Taxonomy'), {'fields': ('group',)}),
   504→        (_('Points'), {'fields': ('points', )}),
   505→        (_('Limits'), {'fields': ('time_limit', ('memory_limit','memory_limit_1','memory_unit'),'allowed_languages',)}),
   506→        # (_('Language'), {'fields': ('allowed_languages',)}),
   507→        # (_('Justice'), {'fields': ('banned_users',)}),
   508→        # (_('History'), {'fields': ('change_message',)}),
   509→    )
   510→    list_display = ['code', 'name', 'show_authors', 'points', 'public_status', 'encryption_status', 'show_public']
   511→    ordering = ['code']
   512→    search_fields = ('code', 'name', 'authors__user__username', 'curators__user__username')
   513→    inlines = [LanguageLimitInline, ProblemDataInline, TestCaseInline, ProblemSolutionInline, ProblemClarificationInline] # [LanguageLimitInline, ProblemClarificationInline, ProblemSolutionInline, ProblemTranslationInline]
   514→    list_max_show_all = 1000
   515→    actions_on_top = True
   516→    actions_on_bottom = True
   517→    list_filter = [
   518→        ('name', ProblemCombinedInputFilter)              
   519→    ]
   520→    form = ProblemForm
   521→    date_hierarchy = 'date'
   522→    change_list_template = 'admin/judge/problem/change_list.html'
   523→    action_form = CustomActionForm
   524→
   525→    
   526→
   527→    def get_actions(self, request):
   528→        actions = super(ProblemAdmin, self).get_actions(request)
   529→
   530→        if request.user.has_perm('judge.change_public_visibility'):
   531→            func, name, desc = self.get_action('make_public')
   532→            actions[name] = (func, name, desc)
   533→
   534→            func, name, desc = self.get_action('make_private')
   535→            actions[name] = (func, name, desc)
   536→
   537→        func, name, desc = self.get_action('update_publish_date')
   538→        actions[name] = (func, name, desc)
   539→
   540→        return actions
   541→
   542→    def get_readonly_fields(self, request, obj=None):
   543→        fields = self.readonly_fields
   544→        fields += ('code',)
   545→        if not request.user.has_perm('judge.change_public_visibility'):
   546→            fields += ('is_public',)
   547→        if not request.user.has_perm('judge.change_manually_managed'):
   548→            fields += ('is_manually_managed',)
   549→        if not request.user.has_perm('judge.problem_full_markup'):
   550→            fields += ('is_full_markup',)
   551→            if obj and obj.is_full_markup:
   552→                fields += ('description',)
   553→        return fields
   554→
   555→    # obj여부에 따라 달라지는 기능 구현
   556→    def get_inlines(self, request, obj=None):
   557→        """객체가 존재하는 경우에만 인라인을 표시하도록 설정."""
   558→        if obj: 
   559→            return super().get_inlines(request, obj)
   560→        return []
   561→    
   562→    def changeform_view(self, request, object_id=None, form_url='', extra_context=None):
   563→        extra_context = extra_context or {}
   564→        if object_id is None:
   565→            extra_context['show_save_and_continue'] = True
   566→            extra_context['show_save'] = False
   567→            extra_context['show_delete'] = False
   568→            extra_context['show_save_and_add_another'] = False
   569→        else:
   570→            extra_context['show_save_and_continue'] = True
   571→            extra_context['show_save'] = True
   572→            extra_context['show_delete'] = True
   573→            extra_context['show_save_and_add_another'] = True
   574→
   575→        return super().changeform_view(request, object_id, form_url, extra_context=extra_context)
   576→    
   577→    def show_authors(self, obj):
   578→        return ', '.join(map(attrgetter('user.username'), obj.authors.all()))
   579→
   580→    show_authors.short_description = _('Authors')
   581→
   582→    def public_status(self, obj):
   583→        """
   584→        관리자 페이지에서 공개/비공개 상태를 pill 스타일로 표시
   585→        기존 X/V 이미지로 제공되던 정보를 공개/비공개 텍스트로 띄우기 위한 함수입니다.
   586→        관련 함수는 모두 같은 이유로 작성되었습니다.
   587→        """
   588→        if obj.is_public:
   589→            return format_html('<span class="pill pill-success">공개</span>')
   590→        else:
   591→            return format_html('<span class="pill pill-danger">비공개</span>')
   592→    
   593→    public_status.short_description = _('공개')
   594→
   595→    def encryption_status(self, obj):
   596→        """관리자 페이지에서 암호화/비암호화 상태를 pill 스타일로 표시"""
   597→        if obj.is_encrypted:
   598→            return format_html('<span class="pill pill-warning">암호화</span>')
   599→        else:
   600→            return format_html('<span class="pill pill-neutral">비암호화</span>')
   601→    
   602→    encryption_status.short_description = _('암호화')
   603→
   604→    def show_public(self, obj):
   605→        return format_html('<a href="{1}">{0}</a>', gettext('View on site'), obj.get_absolute_url())
   606→
   607→    show_public.short_description = '문제 바로가기'
   608→
   609→    def _rescore(self, request, problem_id):
   610→        from judge.tasks import rescore_problem
   611→        transaction.on_commit(rescore_problem.s(problem_id).delay)
   612→
   613→    def update_publish_date(self, request, queryset):
   614→        count = queryset.update(date=timezone.now())
   615→        self.message_user(request, ngettext("%d problem's publish date successfully updated.",
   616→                                            "%d problems' publish date successfully updated.",
   617→                                            count) % count)
   618→
   619→    update_publish_date.short_description = _('Set publish date to now')
   620→
   621→    def make_public(self, request, queryset):
   622→        count = queryset.update(is_public=True)
   623→        for problem_id in queryset.values_list('id', flat=True):
   624→            self._rescore(request, problem_id)
   625→        self.message_user(request, ngettext('%d problem successfully marked as public.',
   626→                                            '%d problems successfully marked as public.',
   627→                                            count) % count)
   628→
   629→    make_public.short_description = _('Mark problems as public')
   630→
   631→    def make_private(self, request, queryset):
   632→        count = queryset.update(is_public=False)
   633→        for problem_id in queryset.values_list('id', flat=True):
   634→            self._rescore(request, problem_id)
   635→        self.message_user(request, ngettext('%d problem successfully marked as private.',
   636→                                            '%d problems successfully marked as private.',
   637→                                            count) % count)
   638→
   639→    make_private.short_description = _('Mark problems as private')
   640→
   641→    def get_queryset(self, request):
   642→        return Problem.get_editable_problems(request.user).prefetch_related('authors__user')
   643→
   644→    def has_change_permission(self, request, obj=None):
   645→        if obj is None:
   646→            return request.user.has_perm('judge.edit_own_problem')
   647→        return obj.is_editable_by(request.user)
   648→
   649→    def formfield_for_manytomany(self, db_field, request=None, **kwargs):
   650→        if db_field.name == 'allowed_languages':
   651→            kwargs['widget'] = CheckboxSelectMultipleWithSelectAll()
   652→        
   653→        return super(ProblemAdmin, self).formfield_for_manytomany(db_field, request, **kwargs)
   654→
   655→    def get_form(self, request, *args, **kwargs):
   656→        form = super(ProblemAdmin, self).get_form(request,*args, **kwargs)
   657→        form.base_fields['authors'].queryset = Profile.objects.filter(user__username=request.user.username)
   658→        form.base_fields['allowed_languages'].initial = Language.objects.all()
   659→        return form
   660→
   661→    def save_model(self, request, obj, form, change):
   662→        # `organizations` will not appear in `cleaned_data` if user cannot edit it
   663→        form.cleaned_data['authors'] = Profile.objects.filter(user__username=request.user.username)
   664→        # form.cleaned_data['allowed_languages'] = Language
   665→        
   666→        # if form.changed_data and 'organizations' in form.changed_data:
   667→        #     obj.is_organization_private = bool(form.cleaned_data['organizations'])
   668→            
   669→        memory_limit_1 = form.cleaned_data.get('memory_limit_1')
   670→        memory_unit = form.cleaned_data.get('memory_unit')
   671→        if memory_unit == 'MB':
   672→            obj.memory_limit = memory_limit_1 * 1024
   673→        else:
   674→            obj.memory_limit = memory_limit_1
   675→        
   676→        #코드 자동 생성
   677→        if obj.code == 'default':
   678→            last_problem = Problem.objects.annotate(
   679→                numeric_value=Cast('code', IntegerField())
   680→            ).order_by('-numeric_value').first()
   681→            if last_problem:
   682→                obj.code = str(int(last_problem.code) + 1)
   683→            else:
   684→                obj.code = str(10000) #10000번부터 문제 시작          
   685→        
   686→        super(ProblemAdmin, self).save_model(request, obj, form, change)
   687→        if (
   688→            form.changed_data and
   689→            # any(f in form.changed_data for f in ('is_public', 'organizations', 'points', 'partial'))
   690→            any(f in form.changed_data for f in ('is_public', 'points', 'partial'))
   691→        ):
   692→            self._rescore(request, obj.id)
   693→            
   694→    def get_urls(self):
   695→        return [
   696→            path('preview/<int:problem_id>', self.preview , name='testcase_preview'),
   697→        ] + super(ProblemAdmin, self).get_urls()
   698→        
   699→    def preview(self,request,problem_id):
   700→        if request.method == 'GET' and request.user.is_staff == True:        
   701→            problem_data = ProblemData.objects.filter(problem=problem_id).first()
   702→
   703→            context = {'json':json.dumps({})}
   704→            error_messages = []
   705→
   706→            if problem_data is not None:
   707→                zip_path = problem_data.zipfile
   708→                testcases = ProblemTestCase.objects.filter(dataset=problem_id)
   709→                dic = {'testcases':[]}
   710→                try:
   711→                    with ZipFile(zip_path) as zip:
   712→                        for idx, testcase in enumerate(testcases):
   713→                            dic['testcases'].append({
   714→                                    "inputFileName": '',
   715→                                    "inputFileBody": '',
   716→                                    "outputFileName": '',
   717→                                    "outputFileBody": '',
   718→                            })
   719→                            try:
   720→                                with zip.open(testcase.input_file) as file: 
   721→                                    content = file.read()
   722→                                    try:
   723→                                        decoded = content.decode('utf-8')
   724→                                    except UnicodeDecodeError:
   725→                                        decoded = None
   726→                                    dic['testcases'][idx]['inputFileName'] = testcase.input_file
   727→                                    dic['testcases'][idx]['inputFileBody'] = decoded
   728→                            except KeyError:
   729→                                error_messages.append("지원하지 않는 input 파일 형식입니다.")
   730→                            try:
   731→                                with zip.open(testcase.output_file) as file: 
   732→                                    dic['testcases'][idx]['outputFileName'] = testcase.output_file
   733→                                    dic['testcases'][idx]['outputFileBody'] = file.read().decode('utf-8')
   734→                            except KeyError:
   735→                                error_messages.append("지원하지 않는 output 파일 형식입니다.")
   736→                    context = {'json':json.dumps(dic)}
   737→                except FileNotFoundError:
   738→                    error_messages.append("ZIP 파일이 존재하지 않습니다.")
   739→                except BadZipfile:
   740→                    error_messages.append("ZIP 파일이 손상되었거나 열 수 없습니다.")
   741→                except Exception as e:
   742→                    error_messages.append(f"알 수 없는 오류가 발생했습니다: {str(e)}")
   743→                context['errors'] = error_messages
   744→            return render(request,'problem/testcase_preview.html',context)
   745→            
   746→            # 요청이 GET이 아니거나, 사용자가 staff가 아닌 경우 적절한 응답 반환
   747→        return HttpResponse("Unauthorized or invalid Get request", status=401)
   748→
   749→    def construct_change_message(self, request, form, *args, **kwargs):
   750→        if form.cleaned_data.get('change_message'):
   751→            return form.cleaned_data['change_message']
   752→        return super(ProblemAdmin, self).construct_change_message(request, form, *args, **kwargs)
   753→
   754→
   755→class ProblemPointsVoteAdmin(admin.ModelAdmin):
   756→    list_display = ('points', 'voter', 'linked_problem', 'vote_time')
   757→    search_fields = ('voter__user__username', 'problem__code', 'problem__name')
   758→    readonly_fields = ('voter', 'problem', 'vote_time')
   759→    action_form = CustomActionForm
   760→
   761→    
   762→
   763→    def get_queryset(self, request):
   764→        return ProblemPointsVote.objects.filter(problem__in=Problem.get_editable_problems(request.user))
   765→
   766→    def has_add_permission(self, request):
   767→        return False
   768→
   769→    def has_change_permission(self, request, obj=None):
   770→        if obj is None:
   771→            return request.user.has_perm('judge.edit_own_problem')
   772→        return obj.problem.is_editable_by(request.user)
   773→
   774→    def lookup_allowed(self, key, value):
   775→        return super().lookup_allowed(key, value) or key in ('problem__code',)
   776→
   777→    def linked_problem(self, obj):
   778→        link = reverse('problem_detail', args=[obj.problem.code])
   779→        return format_html('<a href="{0}">{1}</a>', link, obj.problem.name)
   780→    linked_problem.short_description = _('problem')
   781→    linked_problem.admin_order_field = 'problem__name'
   782→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
